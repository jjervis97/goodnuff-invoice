from datetime import datetime

# ----- VIN TOOLS -----

VIN_HISTORY = GARAGE / "vin_history.csv"

# characters that are NOT allowed in a VIN
VIN_FORBIDDEN = set("IOQ")

# simple country decode by first character
VIN_COUNTRY = {
    "1": "USA", "4": "USA", "5": "USA",
    "2": "Canada",
    "3": "Mexico",
    "J": "Japan",
    "K": "Korea",
    "S": "United Kingdom",
    "V": "France / Spain",
    "W": "Germany",
    "Y": "Scandinavia",
    "Z": "Italy",
}

# very small manufacturer table for common stuff
VIN_WMI = {
    "1FA": "Ford (USA)",
    "1FB": "Ford (USA)",
    "1F1": "Ford (USA)",
    "1G1": "Chevrolet (USA)",
    "1G2": "Pontiac (USA)",
    "1G3": "Oldsmobile (USA)",
    "1G4": "Buick (USA)",
    "1G6": "Cadillac (USA)",
    "1GC": "Chevrolet Truck (USA)",
    "1GT": "GMC Truck (USA)",
    "2G1": "Chevrolet (Canada)",
    "2T3": "Toyota (Canada)",
    "2HK": "Honda (Canada)",
    "3FA": "Ford (Mexico)",
    "3GN": "GM (Mexico)",
    "3VW": "Volkswagen (Mexico)",
    "JHM": "Honda (Japan)",
    "JH4": "Acura (Japan)",
    "JTD": "Toyota (Japan)",
    "JT3": "Toyota Truck (Japan)",
    "JM1": "Mazda (Japan)",
    "JN1": "Nissan (Japan)",
    "JN8": "Nissan Truck/SUV (Japan)",
    "KMH": "Hyundai (Korea)",
    "KND": "Kia (Korea)",
    "SAL": "Land Rover (UK)",
    "SCF": "Aston Martin (UK)",
    "WAU": "Audi (Germany)",
    "WBA": "BMW (Germany)",
    "WDC": "Mercedes-Benz (Germany)",
    "WDB": "Mercedes-Benz (Germany)",
    "ZAM": "Maserati (Italy)",
    "ZFF": "Ferrari (Italy)",
}




# ------------ VIN HELPER FUNCTIONS ------------

def vin_clean(v: str) -> str:
    """Uppercase + strip spaces."""
    return v.strip().upper()


def vin_basic_checks(v: str) -> tuple[bool, str]:
    """Length + forbidden chars only."""
    if len(v) != 17:
        return False, "VIN must be exactly 17 characters."

    bad = [ch for ch in v if ch in VIN_FORBIDDEN]
    if bad:
        return False, f"VIN cannot contain I, O, or Q (found: {''.join(bad)})."

    for ch in v:
        if not ch.isalnum():
            return False, "VIN must be letters and numbers only."

    return True, ""


def vin_transliterate(ch: str) -> int:
    """Letter â†’ number for check-digit calc."""
    table = {
        "A": 1, "B": 2, "C": 3, "D": 4, "E": 5, "F": 6, "G": 7, "H": 8,
        "J": 1, "K": 2, "L": 3, "M": 4, "N": 5, "P": 7, "R": 9,
        "S": 2, "T": 3, "U": 4, "V": 5, "W": 6, "X": 7, "Y": 8, "Z": 9,
    }
    if ch.isdigit():
        return int(ch)
    return table.get(ch, 0)


def vin_calc_check_digit(v: str) -> str:
    """ISO 3779 check-digit for VIN."""
    weights = [8, 7, 6, 5, 4, 3, 2, 10,
               0, 9, 8, 7, 6, 5, 4, 3, 2]
    total = 0
    for i, ch in enumerate(v):
        value = vin_transliterate(ch)
        total += value * weights[i]
    remainder = total % 11
    return "X" if remainder == 10 else str(remainder)


def vin_check_digit_status(v: str) -> tuple[bool, str]:
    actual = v[8]
    expected = vin_calc_check_digit(v)
    ok = (actual == expected)
    msg = f"Actual {actual}, expected {expected}"
    return ok, msg


def vin_decode_year_code(code: str) -> int | None:
    """Return model year (rough guess)."""
    year_map = {
        "A": 1980, "B": 1981, "C": 1982, "D": 1983,
        "E": 1984, "F": 1985, "G": 1986, "H": 1987,
        "J": 1988, "K": 1989, "L": 1990, "M": 1991,
        "N": 1992, "P": 1993, "R": 1994, "S": 1995,
        "T": 1996, "V": 1997, "W": 1998, "X": 1999,
        "Y": 2000,
        "1": 2001, "2": 2002, "3": 2003, "4": 2004,
        "5": 2005, "6": 2006, "7": 2007, "8": 2008,
        "9": 2009,
    }
    base = year_map.get(code)
    if base is None:
        return None

    # VIN codes repeat every 30 years; bias toward newer vehicles.
    this_year = datetime.now().year
    year = base
    while year + 30 <= this_year + 1:
        year += 30
    return year


def vin_decode_country_and_make(v: str) -> tuple[str, str]:
    first = v[0]
    wmi = v[:3]

    country = VIN_COUNTRY.get(first, "Unknown / Other")
    make = VIN_WMI.get(wmi, "Unknown manufacturer")

    return country, make


def vin_prompt() -> str | None:
    gn_header("VIN TOOLS")
    vin = vin_clean(input("\nEnter VIN (17 chars, or Enter to cancel): "))
    if not vin:
        pause("Cancelled.")
        return None

    ok, msg = vin_basic_checks(vin)
    if not ok:
        pause(f"Invalid VIN: {msg}")
        return None

    return vin


def vin_save_history(vin: str,
                     country: str,
                     make: str,
                     year: int | None,
                     chk_ok: bool) -> None:
    VIN_HISTORY.parent.mkdir(parents=True, exist_ok=True)
    is_new = not VIN_HISTORY.exists()

    with VIN_HISTORY.open("a", newline="", encoding="utf-8") as f:
        if is_new:
            f.write("timestamp,vin,country,make,year,check_ok\n")
        ts = datetime.now().isoformat(timespec="seconds")
        y = str(year) if year is not None else ""
        ok_flag = "yes" if chk_ok else "no"
        f.write(f"{ts},{vin},{country},{make},{y},{ok_flag}\n")


def vin_show_history() -> None:
    gn_header("VIN HISTORY")
    if not VIN_HISTORY.exists():
        print("\nNo VIN lookups recorded yet.\n")
        pause()
        return

    print("\nRecent VIN lookups:\n")
    # print last ~20 lines (skip header)
    lines = VIN_HISTORY.read_text(encoding="utf-8").splitlines()
    for line in lines[-20:]:
        if line.startswith("timestamp"):
            continue
        print("  " + line)

    print("\nFormat: time, VIN, country, make, year, check_ok\n")
    pause()


def vin_open_in_browser(vin: str) -> None:
    url = (
        "https://vpic.nhtsa.dot.gov/decoder/"
        f"VinDecoder?VIN={vin}&ModelYear="
    )
    print(f"\nOpening NHTSA VIN decoder in browser...")
    os.system(f'xdg-open "{url}" >/dev/null 2>&1')
    print("If it errors, check your internet connection.\n")


def vin_decode_local(vin: str) -> None:
    country, make = vin_decode_country_and_make(vin)
    year = vin_decode_year_code(vin[9])
    chk_ok, chk_msg = vin_check_digit_status(vin)
    plant = vin[10]
    serial = vin[11:]

    gn_header("VIN QUICK DECODE")

    print(f"VIN:          {vin}")
    print(f"Country:      {country}")
    print(f"Manufacturer: {make}")
    if year is not None:
        print(f"Model year:   ~{year} (from 10th digit)")
    else:
        print("Model year:   Unknown code")

    print(f"Plant code:   {plant}  (11th digit)")
    print(f"Serial:       {serial}")
    print(f"Check digit:  {'OK' if chk_ok else 'MISMATCH'} "
          f"({chk_msg})")

    print("\nUse the NHTSA link for full body/engine/options.\n")

    # save to history
    vin_save_history(vin, country, make, year, chk_ok)

    # optional: open web?
    ans = input("Open full NHTSA decoder in browser? [y/N]: ").strip()
    if ans.lower().startswith("y"):
        vin_open_in_browser(vin)

    pause()
    
    
    
    
    def run_vin_menu() -> None:
    while True:
        gn_header("VIN TOOLS")

        print("1) Quick VIN decode (local)")
        print("2) Open VIN in NHTSA browser")
        print("3) View VIN history")
        print("4) Back\n")

        choice = input("Choose an option [1-4]: ").strip()

        if choice == "1":
            vin = vin_prompt()
            if vin:
                vin_decode_local(vin)

        elif choice == "2":
            vin = vin_prompt()
            if vin:
                vin_open_in_browser(vin)
                pause()

        elif choice == "3":
            vin_show_history()

        elif choice in ("4", "q", "Q"):
            return

        else:
            pause("Invalid choice.")
            
            
print("1) Customer Menu")
print("2) Create New Invoice")
print("3) View Invoice History")
print("4) System / Tools")
print("5) Expenses & Write-Offs")
print("6) VIN Tools")
print("7) Exit\n")

choice = input("Choose an option [1-7]: ").strip()


elif choice == "6":
    run_vin_menu()
elif choice == "7":
    print("\nGood 'Nuff out.\n")
    break